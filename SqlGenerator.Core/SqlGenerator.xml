<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SqlGenerator</name>
    </assembly>
    <members>
        <member name="T:SqlGenerator.Discover.DiscoverStrategy">
            <summary>
            Which strategy will follow the application to guess field name, data types and other field properties. Default <see cref="F:SqlGenerator.Discover.DiscoverStrategy.FieldDefDescriptor"/>
            </summary>
        </member>
        <member name="F:SqlGenerator.Discover.DiscoverStrategy.Auto">
            <summary>
            Try to do the best to guess the information
            </summary>
            <remarks>
            If there is a connections string it will use it to get the scheme information.
            If there is not a connection string, try to parse field names as field descriptors. If it encounter errors,
            then it try the get only field names and guess data types
            </remarks>
        </member>
        <member name="F:SqlGenerator.Discover.DiscoverStrategy.ConnectToDatabase">
            <summary>
            Uses then <see cref="P:SqlGenerator.Specification.ConnectionString"/> and retrieves the table schema
            </summary>
            <remarks>
            If <see cref="P:SqlGenerator.Specification.ConnectionString"/> is empty an exception is thrown in the <see cref="M:SqlGenerator.Sources.ISource.Load(System.String)"/> method call
            </remarks>
        </member>
        <member name="F:SqlGenerator.Discover.DiscoverStrategy.FieldDefDescriptor">
            <summary>
            Fields have a specific descriptor that allow to infer the neccesary information about field name, data type and properties.
            </summary>
            <seealso cref="T:SqlGenerator.Discover.FieldDefParserStrategy"/>
        </member>
        <member name="F:SqlGenerator.Discover.DiscoverStrategy.FieldNamesOnly">
            <summary>
            Retrieves only field names. Data type is guessed for each data row and column
            </summary>
        </member>
        <member name="F:SqlGenerator.Discover.DiscoverStrategy.GuestDataType">
            <summary>
            Get a sample of data of max <see cref="P:SqlGenerator.Specification.RowsToScan"/> rows and, for each column try to guess the data type and other properties
            </summary>
        </member>
        <member name="F:SqlGenerator.Discover.FieldDefParserStrategy.dataTypes">
            <summary>
            Translate char from <see cref="F:SqlGenerator.Discover.FieldDefParserStrategy.patternFieldType"/> to <see cref="T:SqlGenerator.FieldType"/>
            </summary>
        </member>
        <member name="P:SqlGenerator.Discover.FieldDefParserStrategy.CurrentToken">
            <summary>Which token are we parsing now</summary>
        </member>
        <member name="P:SqlGenerator.Discover.FieldDefParserStrategy.Descriptor">
            <summary>Descriptor Which we are parsing now</summary>
        </member>
        <member name="P:SqlGenerator.Discover.FieldDefParserStrategy.result">
            <summary>Current parse result</summary>
        </member>
        <member name="T:SqlGenerator.Discover.ParseResult">
            <summary>
            Result of parsing a FieldDef descriptor
            </summary>
        </member>
        <member name="P:SqlGenerator.Discover.ParseResult.Field">
            <summary>
            If no errors, Gets an nitialized and valid <see cref="T:SqlGenerator.FieldDef"/>. If there is any error, this field is <c>null</c>
            </summary>
        </member>
        <member name="P:SqlGenerator.Discover.ParseResult.Success">
            <summary>
            <c>true</c> if no parsing errors
            </summary>
        </member>
        <member name="P:SqlGenerator.Discover.ParseResult.ErrorMessage">
            <summary>
            Readable error list as multiline string
            </summary>
        </member>
        <member name="P:SqlGenerator.Discover.ParseResult.Errors">
            <summary>
            Parse errors found. If <see cref="P:SqlGenerator.Discover.ParseResult.Success"/> this collection is empty
            </summary>
        </member>
        <member name="T:SqlGenerator.FieldDef">
            <summary>
            Field definition metadata
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.Name">
            <summary>
            Field name
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.OrdinalPosition">
            <summary>
            Number of column where the field is defined
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.MaxLength">
            <summary>
            MaxLenght. If type is other <see cref="F:SqlGenerator.FieldType.Text"/> this property is ignored
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.IsNullable">
            <summary>
            Field is nullable. Default <c>true</c>
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.IsKey">
            <summary>
            Field is part of the primary key
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.FieldType">
            <summary>
            Field data type. See types: <see cref="P:SqlGenerator.FieldDef.FieldType"/>
            </summary>
        </member>
        <member name="P:SqlGenerator.FieldDef.Format">
            <summary>
            Format for <see cref="F:SqlGenerator.FieldType.Bool"/> and <see cref="F:SqlGenerator.FieldType.DateTime"/>. Ignored for other data types
            </summary>
        </member>
        <member name="T:SqlGenerator.FieldType">
            <summary>
            Enum the different data types distinguised by the sql generator
            </summary>
        </member>
        <member name="F:SqlGenerator.FieldType.Auto">
            <summary>
            Field type not set. Will try to guess for each read value.
            </summary>
            <remarks>
            When <see cref="T:SqlGenerator.Discover.DiscoverStrategy"/> is <see cref="F:SqlGenerator.Discover.DiscoverStrategy.GuestDataType"/> and all scaned rows are <c>null</c>, FieldType remains Auto
            </remarks>
        </member>
        <member name="F:SqlGenerator.FieldType.Text">
            <summary>
            If field has text or other field types have failed.
            </summary>
        </member>
        <member name="F:SqlGenerator.FieldType.Numeric">
            <summary>
            Field has only numeric values. Can be integer, float.... For text sources, decimal separator is the system default
            </summary>
        </member>
        <member name="F:SqlGenerator.FieldType.DateTime">
            <summary>
            Field seems to have date or date time values.
            </summary>
            <remarks>
            Do not support formats with month names. Date separator can be [/], [-] or [.] Hour separator is [:]
            Detect formats like yyyy-mm-dd, mm-dd-yyyy, dd-mm-yyyy. With year in 2 or 4 digits, and day and month with 1 or 2 digits
            Hour part can be hh:mm with 1 or 2 digits. Any trailing chars will be considered seconds part, which allow milliseconds
            12 hours format with am/pm not allowed. Please use allways 24 hours format
            </remarks>
        </member>
        <member name="F:SqlGenerator.FieldType.Bool">
            <summary>
            Field is considered boolean as it has only 1 or 2 values (apart of null)
            </summary>
            <remarks>
            The <see cref="P:SqlGenerator.FieldDef.Format"/> field will contain the text values for true/false, separated with [/]
            If <see cref="P:SqlGenerator.FieldDef.Format"/> is not specified, allowed pairs are: true/false, yes/no, y/n, 1/0, -1/0, x/&lt;space&gt;
            </remarks>
        </member>
        <member name="T:SqlGenerator.Sources.ISource">
            <summary>
            Iterface for all data sources
            </summary>
        </member>
        <member name="P:SqlGenerator.Sources.ISource.TableName">
            <summary>
            Name of the table
            </summary>
        </member>
        <member name="P:SqlGenerator.Sources.ISource.TableDef">
            <summary>
            Table schema (or definition). See <see cref="P:SqlGenerator.Sources.ISource.TableDef"/>
            </summary>
        </member>
        <member name="M:SqlGenerator.Sources.ISource.Load(System.String)">
            <summary>
            Load the information from de source file
            </summary>
            <param name="fileName">File name with the data</param>
        </member>
        <member name="T:SqlGenerator.Sources.SourceFactory">
            <summary>
            Selects the class that will read the soruce data from the file extension
            </summary>
        </member>
        <member name="M:SqlGenerator.Sources.SourceFactory.#ctor(System.IServiceProvider,Microsoft.Extensions.Logging.ILogger{SqlGenerator.Sources.SourceFactory})">
            <summary>
            Constructor
            </summary>
            <param name="serviceProvider">DI service provider</param>
            <param name="logger">Logger</param>
        </member>
        <member name="M:SqlGenerator.Sources.SourceFactory.GetSource(System.String)">
            <summary>
            Get the specific <see cref="T:SqlGenerator.Sources.ISource"/> from the file extension
            </summary>
            <param name="extension">file extension</param>
            <returns><see cref="T:SqlGenerator.Sources.ISource"/></returns>
        </member>
        <member name="T:SqlGenerator.Specification">
            <summary>
            Indications to load data and generate the SQL scripts
            </summary>
        </member>
        <member name="P:SqlGenerator.Specification.TableName">
            <summary>
            Table name used to generate the SQL scripts. If ommited, can be infered by the <see cref="T:SqlGenerator.Discover.IFieldDefStrategy"/>
            </summary>
        </member>
        <member name="P:SqlGenerator.Specification.ConnectionString">
            <summary>
            Connection string to get the table scheme from. This property is mandatory if <see cref="F:SqlGenerator.Discover.DiscoverStrategy.ConnectToDatabase"/> strategy is used
            </summary>
        </member>
        <member name="P:SqlGenerator.Specification.DiscoverStrategy">
            <summary>
            Which stratgy will follow to guess field names and data types. Default <see cref="F:SqlGenerator.Discover.DiscoverStrategy.FieldDefDescriptor"/>
            </summary>
        </member>
        <member name="P:SqlGenerator.Specification.RowsToScan">
            <summary>
            Number of rows to scan to try to guess the fields data type
            </summary>
            <remarks>
            Depending on the value of <see cref="P:SqlGenerator.Specification.DiscoverStrategy"/>
            <list type="bullet">
            <item><term><see cref="F:SqlGenerator.Discover.DiscoverStrategy.GuestDataType"/></term>
            <description>This field is mandatory/></description>
            </item>
            <item><term><see cref="F:SqlGenerator.Discover.DiscoverStrategy.FieldNamesOnly"/></term>
            <description>
            If this field has no value or it is 0, <see cref="T:SqlGenerator.FieldType"/> will be <see cref="F:SqlGenerator.FieldType.Auto"/> 
            and data type will be guessed in each occurrence. If has a value greather than 0, field data types will be
            guessed scaning up to the specified row
            </description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:SqlGenerator.Specification.WorkSheetName">
            <summary>
            For Excel files, thw worksheet that contains the source data. If not specified, the first worksheet (by index) is taken
            </summary>
        </member>
        <member name="T:SqlGenerator.SqlGeneratorExtensions">
            <summary>
            Dependency injection extensions for SqlGenerator
            </summary>
        </member>
        <member name="M:SqlGenerator.SqlGeneratorExtensions.AddSqlGenerator(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Register the neccesary DI in the services colection
            </summary>
        </member>
        <member name="T:SqlGenerator.TableDef">
            <summary>
            Table definition schema
            </summary>
        </member>
        <member name="P:SqlGenerator.TableDef.TableName">
            <summary>
            Name of the table
            </summary>
        </member>
        <member name="P:SqlGenerator.TableDef.Fields">
            <summary>
            Collection of <see cref="T:SqlGenerator.FieldDef"/>
            </summary>
        </member>
        <member name="P:SqlGenerator.TableDef.Item(System.Int32)">
            <summary>
            Return <see cref="T:SqlGenerator.FieldDef"/> by position
            </summary>
            <param name="i">Field position</param>
        </member>
        <member name="P:SqlGenerator.TableDef.Item(System.String)">
            <summary>
            Return <see cref="T:SqlGenerator.FieldDef"/> by name
            </summary>
            <param name="name">name of the matching field</param>
        </member>
        <member name="P:SqlGenerator.TableDef.Keys">
            <summary>
            Collection of field names that belong to the primary key. Used to generate Update SQL scripts
            </summary>
        </member>
    </members>
</doc>
